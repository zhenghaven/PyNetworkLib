#!/usr/bin/env python3
# -*- coding:utf-8 -*-
###
# Copyright (c) 2025 Haofan Zheng
# Use of this source code is governed by an MIT-style
# license that can be found in the LICENSE file or at
# https://opensource.org/licenses/MIT.
###


import threading

from ....Utils.TOTP import Totp
from ....Utils.TOTPToken import CalcHashedTotpToken
from ...HTTP.DownstreamHandlerBase import DownstreamHandlerBase
from ...HTTP.PreHandler import PreHandler
from ...HTTP.Utils.HandlerState import HandlerState
from ...HTTP.Utils.HostField import HOST_FIELD_TYPES


class TotpToken(DownstreamHandlerBase):
	'''A TOTP token authenticator that authenticates the requests
	being handled using a token generated from the TOTP.
	'''

	def __init__(
		self,
		totp: Totp,
		downstreamHTTPHdlr: DownstreamHandlerBase,
	) -> None:
		'''
		Constructor for the RateLimiter class.
		'''

		super().__init__()

		self._totp = totp
		self._downstreamHTTPHdlr = downstreamHTTPHdlr

	def _UnauthenticatedResp(
		self,
		pyHandler: PreHandler,
		logMsgFmtAndArgs: tuple[str, ...],
	) -> None:
		pyHandler.LogDebug(*logMsgFmtAndArgs)
		pyHandler.SetCodeAndTextMessage(code=403, message='Forbidden')
		return

	def HandleRequest(
		self,
		host: HOST_FIELD_TYPES,
		relPath: str,
		pyHandler: PreHandler,
		handlerState: HandlerState,
		reqState: dict,
		terminateEvent: threading.Event,
	) -> None:
		'''Handle the request.'''

		# the format of the token is:
		# Authentication: TOTP_TOKEN <random_salt>:<hashed_totp>
		# where <hashed_totp> is calculated as:
		#   sha512(<random_salt> + ":" + <current_totp>)
		# where <random_salt> is a random string generated by the client
		# and it should be at least 16 characters long

		authHeader = pyHandler.headers.get('Authorization')
		if authHeader is None:
			self._UnauthenticatedResp(
				pyHandler,
				('No Authorization header found in the request',),
			)
			return

		authHeader = authHeader.split(' ')
		if len(authHeader) != 2:
			self._UnauthenticatedResp(
				pyHandler,
				('Invalid Authorization header format',),
			)
			return
		authType = authHeader[0]

		if authType != 'TOTP_TOKEN':
			self._UnauthenticatedResp(
				pyHandler,
				('Invalid Authorization type',),
			)
			return
		authToken = authHeader[1]

		splittedToken = authToken.split(':')
		if len(splittedToken) != 2:
			self._UnauthenticatedResp(
				pyHandler,
				('Invalid token format',),
			)
			return
		randomSalt = splittedToken[0]
		hashedTotp = splittedToken[1]

		if len(randomSalt) < 16:
			self._UnauthenticatedResp(
				pyHandler,
				('Invalid random salt length',),
			)
			return

		currTotp = self._totp.Now()
		expHash = CalcHashedTotpToken(
			currTotp=currTotp,
			randomSalt=randomSalt,
		)

		if expHash == hashedTotp:
			# the token is valid
			reqState['current_totp'] = currTotp

			pyHandler.LogDebug('Token is accepted')
			self._downstreamHTTPHdlr.HandleRequest(
				host,
				relPath,
				pyHandler,
				handlerState,
				reqState,
				terminateEvent,
			)
			return

		# the token is invalid
		self._UnauthenticatedResp(
			pyHandler,
			('Invalid token',),
		)

